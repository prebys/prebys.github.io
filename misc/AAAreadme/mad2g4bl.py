#!/usr/bin/python

# This is a program to convert an optics file generated by 
# MAD or MADX in to a g4Beamline fragment
# Program will place elements based on the TYPE parameter, which must be 
# set, either in a column or in an auxiliary file.
#
# It requires the columns:
#   KEYWORD, NAME, S, L
# Optional columns:
#   TYPE,ANGLE, K1L, K2L, TILT
# will be set to zero (or blank) if they are not present.  If "TYPE" is not
# present, the --typefile=<file> option must be used to provide a type file.
#
# Columns may be in any order and additional columns will be ignored!
#
#  Revision history:
#   23-DEC-2014  E. Prebys  First stable version
#   10-MAR-2020  E. Prebys  Added "--centre" option to deal with "centre" option in Twiss
#   12-MAR-2020  E. Prebys  Fixed print() statements to be Python 3 compatible
#

import numpy as np
import getopt
import sys


# list of allowed keywords.  All others will be ignored.
keys = ['RBEND','SBEND','QUADRUPOLE','RCOLLIMATOR','HKICKER','VKICKER']

# define some particles and constants
masses = {}
charges = {}
masses['proton'] = 938.2726218
charges['proton'] = +1.
masses['antiproton'] = 938.2726218
charges['antiproton'] = -1.
masses['electron'] = 0.510998910
charges['electron'] = -1.
masses['positron'] = 0.510998910
charges['positron'] = +1.
masses['mu+'] = 105.6583715
charges['mu+'] = +1.
masses['mu-'] = 105.6583715
charges['mu-'] = -1.


c = 299792458.

# defaults 
merge = True
energy = 8000.
particle = 'proton'
startProcess=True
firstElement=None
lastElement=None
outputFile=None
split=False  # This will cause the program to put out separate files whenever a cornerarc is detected.
centre=False # This must be set if MADX used the "centre" option
# This file will hold the types, if they are specified in a separate file
types = {}

def usage():
  print ("Usage: mad2g4bl.py [--nomerge --split --centre --typefile=<file> --outputfile=<file> --firstelement=<NAME> --lastelement=<NAME> --energy=<MeV> --particle=<particle>] <inputfile>")

# Get the command options
try:
  opts, args = getopt.getopt(sys.argv[1:],"",["nomerge","split","centre","typefile=","energy=","particle=","outputfile=","firstelement=","lastelement="])
  if len(args)<1:
    usage()
    sys.exit(2)
  inputFile = args[0]
  for opt in opts:
    if opt[0] == "--nomerge":
      merge=False
    elif opt[0] == "--split":
      split=True 
    elif opt[0] == "--centre":
      centre=True; 
    elif opt[0] == "--energy":
      energy = float(opt[1])
    elif opt[0] == "--particle":
      particle = opt[1].lower()
      if particle not in masses:
        print ('Unknown particle %s. Known particle list:'%particle, masses)
        sys.exit(2)
    elif opt[0] == "--typefile":
      typeFile = opt[1]
      print ('Will read type definitions from file %s'%typeFile)
      tf = open(typeFile)
      for line in tf:
        parts = line.split(",")
        if len(parts)>=2:
          types[parts[0].strip().upper()] = parts[1].strip().upper()
      tf.close()
    elif opt[0] == "--outputfile":
      outputFile = opt[1]
    elif opt[0] == "--firstelement":
      firstElement = opt[1]
      startProcess = False
    elif opt[0] == "--lastelement":
      lastElement = opt[1]
    

except getopt.GetoptError:
  usage()
  sys.exit(2)

# Define kinematic parameters
mass = masses[particle]
q = charges[particle]
E = energy+mass
p = np.sqrt(E**2-mass**2)
brho = p*1e6/c


print ('Particle type: %s (mass=%f MeV/c^2)'%(particle,masses[particle]))
print ('Kinetic Energy: %f MeV'%energy)
print ('Brho: %f T-m'%brho)
if merge:
  print ("Will merge split elements")
else:
  print ("Will keep split elements separate")

# Define the output file
if outputFile is None:
  base=inputFile
  idx = inputFile.rfind('.')
  if idx>0:
    base=inputFile[:idx]
  outputFile = base+".g4bl"

# Parse the column headers
def parseHeader(line):
  parts=line.split()
  cols = {}
  for i in range(0,len(parts)):
     cols[parts[i]] = i
  return cols
  required = ['KEYWORD','NAME','S','L']
  for col in required:
    if col not in cols:
      print ('Error: %s column required. Exiting'%col)
      sys.exit(2)
  return cols 

# Parse a line    
def parseLine(line,cols):
  parts = line.split()
  KEYWORD = parts[cols['KEYWORD']].strip('"').upper()
  if KEYWORD in keys:
    params = {}
    params['KEYWORD']=KEYWORD
    params['NAME'] =  parts[cols['NAME']].strip('"').upper()
    if 'TYPE' in cols:
      params['TYPE'] = parts[cols['TYPE']].strip('"').upper()
    else:
      params['TYPE'] = '~'

    floatcols = ['S','L','ANGLE','K1L','K2L','TILT']

    for col in floatcols:
      if col in cols:
        params[col] = float(parts[cols[col]])
      else:
        params[col] = 0.
        
    # If the --centre option is set, correct the S to the end of the element
    if(centre):
      params['S'] += 0.5*params['L']
     
    return params
  else:
    return 

# Write a file header to the output file    
def fileHeader():
  outFile.write("#\n# This file was generated by mad2g4bl.py, with command:\n# >mad2g4bl")
  for arg in sys.argv[1:]:
    outFile.write(' '+arg)
  outFile.write('\n#\n')

# This converts a string to a name which is a legal parameter in g4bl
# by replacing '.', '-', or '$' with '_'
#
def legalParam(name):
  return name.replace('-','_').replace('.','_').replace('$','_')
  
inFile = open(inputFile,'r')
if not split:
  outFileName = outputFile
else:
  print ('The split option has been selected.  Output will be split at coordinate transformations')
  fileSegment=0
  outFileName = '%s_seg%d'%(outputFile,fileSegment)

outFile = open(outFileName,'w')
fileHeader()



#
# Loop over the file and parse the elements
#
elements = []
for line in inFile:
  if (line[0] == '@') or (line[0]=='$'):
     continue
  elif line[0] == '*':
     cols = parseHeader(line[1:])
     continue

  if cols is None:
    print ('Error: No column headers found in optics file')
    sys.exit(2)
    
  params = parseLine(line,cols)
  
  if params is not None:

# If a type list is specified, that will override the
# definition in the file

    if params['NAME'] in types:
      params['TYPE'] = types[params['NAME']].upper()      
    elements.append(params)



inFile.close()

# go through and merge split elements. Probably an easier way to do this
if merge:
  for i in range(0,len(elements)-1):
    element1 = elements[i]
    element2 = elements[i+1]
    if element2['NAME']==element1['NAME'] and element2['S']==(element1['S']+element2['L']):
      element2['L']+=element1['L']
      element2['ANGLE']+=element1['ANGLE']
      element2['K1L']+=element1['K1L']
      element2['K2L']+=element1['K2L']
      element1['KEYWORD']='DELETE'

  for i in range(len(elements)-1,-1,-1):
    element = elements[i]
    if element['KEYWORD']=='DELETE':
      elements.pop(i)

firstOutput=True
lastZ=0.

typeLengths=[]

# 
# This is the main look of the program.  Go through each
# element and translate it to a g4beamline place command.
#
for element in elements:
     KEYWORD = element['KEYWORD']
     NAME = element['NAME']
     TYPE = element['TYPE']
     S = element['S']
     L = element['L']
     ANGLE = element['ANGLE']
     K1L = element['K1L']
     K2L = element['K2L']
     TILT = element['TILT']

     # dashes in names and types can cause problems, so fix them

     # skip drifts at this point
     if KEYWORD=='DRIFT':
       continue


     if not startProcess:
       if NAME==firstElement:
         startProcess=True
       else:
         continue
 
     check = TYPE[0]
     if (check=='~') or (check=='0'):
       print ("Skipping %s %s (s=%f) because no TYPE specified."%(KEYWORD,NAME,S))
       continue

     zBack = S*1000.
     length = L*1000.
     zFront = zBack-length
     zMid = zFront+(length)/2.
     
     if firstOutput:
       outFile.write('param Start_%s=%f\n'%(legalParam(outputFile),zFront))
       firstOutput=False
        
     outFile.write('####################################################################\n#Placing %s (TYPE=%s, length=%f) at z=%f\n'%(NAME,TYPE,length,zFront))
     outFile.write('param Start_%s=%f\nparam End_%s=%f\n'%(legalParam(NAME),zFront,legalParam(NAME),zBack))
# this line will allow the iron lengths to be overidden
     if (KEYWORD=='RBEND') or (KEYWORD=='HKICKER') or (KEYWORD=='VKICKER') or (KEYWORD=='QUADRUPOLE'):
       if TYPE not in typeLengths:
         outFile.write('param -unset ironLength_%s=%f\n'%(legalParam(TYPE),length)) 
         typeLengths.append(TYPE)      
         

     if (KEYWORD=='RBEND') or (KEYWORD=='HKICKER') or (KEYWORD=='VKICKER') or (KEYWORD=='SBEND'):
       if (KEYWORD=='SBEND'):
         By = brho*ANGLE/L
       else:
         By = q*brho*2*np.sin(ANGLE/2)/L    

       angle = ANGLE*180/np.pi
       zrot = TILT*180/np.pi
# Not quite ready to deal with partial rotations
       if zrot<45.:
         zrot=0.
       else: 
         zrot=90.

       if By==0:
          sagitta=0
       else:
          rho = q*brho/By*1000.  #rho, signed, in mm
          sagitta=rho*(1-np.cos(ANGLE/2))
    
# The field length will be fixed to the length in MAD.  The ironLength will
# default to this, but can be overridden by a previous definition.
# Use a variable for B field to allow it to be overridden.
       outFile.write('param -unset By_%s=%f\n'%(legalParam(NAME),By))
# Much simpler for an SBEND than an RBEND
# SBEND case
       if KEYWORD=='SBEND':
         if zrot==90.:
           rotstring = 'Z90'
         else:
           rotstring = 'Z0'     
         zPos = zFront
         
         fieldCenterRadius = np.abs(length/ANGLE)
         outFile.write('place %s rename=%s z=%f By=$By_%s fieldCenterRadius=%f rotation=%s\n'%(TYPE,NAME,zPos,NAME,fieldCenterRadius,rotstring))
# RBEND case
       else:
         latshift = sagitta/2*np.cos(ANGLE/2)
         zPos = zFront+np.abs(sagitta/2*np.sin(ANGLE/2))
          
         if zrot==90.:
           rotstring = 'Z90,X%f y=%f'%(angle/2,latshift)
         else:
           rotstring = 'Y%f x=%f'%(-angle/2,latshift)      
         outFile.write('place %s front=1 rename=%s z=%f By=$By_%s fieldLength=%f ironLength=$ironLength_%s rotation=%s\n'%(TYPE,NAME,zPos,NAME,length,TYPE.replace('-','_'),rotstring))

       if (By!=0) and ((KEYWORD=='RBEND') or (KEYWORD=='SBEND')):
# if the split option has been set, split the file just before the cornerarc, so we can place elements 
# there's a coordinate transformation
         if split:
            outFile.close()
            fileSegment += 1
            outFileName = '%s_seg%d'%(outputFile,fileSegment)
            outFile = open(outFileName,'w')
            fileHeader()
            
         outFile.write('cornerarc centerRadius=%f radiusCut=300. z=%f angle=%f rotation=Z%.3f\n'%(np.abs(rho),zFront,-angle,zrot))
     elif KEYWORD=='QUADRUPOLE':
       gradient = q*K1L/L*brho
       outFile.write('place %s front=1 rename=%s z=%f gradient=%f fieldLength=%f ironLength=$ironLength_%s\n'%(TYPE,NAME,zFront,gradient,length,TYPE.replace('-','_')))
     elif KEYWORD=='RCOLLIMATOR':
# Collimators are often groups, so length cannot be redefined
       outFile.write('place %s front=1 rename=%s z=%f\n'%(TYPE,NAME,zFront))

     lastZ = zBack
     if lastElement is not None:
       if NAME==lastElement:
         break

outFile.write('param End_%s=%f\n'%(legalParam(outputFile),lastZ))

outFile.close()
     
     
         
         
       
        
